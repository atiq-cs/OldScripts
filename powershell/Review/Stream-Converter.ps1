<# Date: 07/29/2013 10:30:35
  Author: Atiq

  Desc:
  An utility to perform various operations on audio/video files.
  This script does not work with file names which contain characters '[' or
  ']'. To work with those apply 'namefix' first.
  as WMP 12 local subtitle also does not work those files.

  Target build as .net core console app

  Convert mkv and flv container to mp4 container

  Conntains foreach syntax for gci

  Usage example:
    Stream-Converter.ps1 convert D:\Video.mkv
    Stream-Converter.ps1 convert D:\Donald duck\Episode-1.avi -o E:\Stock_Video
    Stream-Converter.ps1 extract D:\Video.mkv audio
  Merge m4a and mp4 video downloaded from youtube.
    Stream-Converter.ps1 merge D:\Video.mp4 (merges audio.m4a and video.mp4)

   # info uses MediaInfo Project
    Stream-Converter.ps1 info D:\Video.mkv
   # uses ffmpeg
    Stream-Converter.ps1 ffinfo D:\Video.mkv

  Convertion Examples,
   Recursively runs on dir,
    Stream-Converter.ps1 convert D:\Videos
    Stream-Converter.ps1 compress-high D:\Videos
   # almost equals to 
    Stream-Converter.ps1 -dir D:\Videos

   # Files that are in SourceDirectory should be converted and compressed for
   supported file extensions
    Stream-Converter.ps1 compress -dir D:\Videos

  Extraction Examples,
   # Extract subtitle (supported: srt, ass, pgs/sup)
    Stream-Converter.ps1 extract D:\Movie.mkv srt
   # Extract subtitle from index for multiple subs
    Stream-Converter.ps1 extract D:\Movie.mkv srt -index 3
  Please note that extraction from video format such as 'mkv' will trigger
  subtitle extraction
  Probably we cannot support fromat dvd_subtitle.

   # Only rename upper case extensions, also fixes [] weird chars
    Stream-Converter.ps1 namefix -dir D:\Downloads
 
 References:
  test for null ref
  https://stackoverflow.com/questions/5111572/how-to-test-for-null-array-in-powershell

  ffmpeg disable metadata map chapters
  https://video.stackexchange.com/questions/20270/ffmpeg-delete-chapters

  ffmpeg metadata
  https://stackoverflow.com/questions/9464617/retrieving-and-saving-media-metadata-using-ffmpeg

  Supported Media Formats in Media Foundation:
    http://msdn.microsoft.com/en-us/library/windows/desktop/dd757927(v=vs.85).aspx
  Decoding info: H.264 Video Decoder:
    http://msdn.microsoft.com/en-us/library/windows/desktop/dd797815(v=vs.85).aspx
  The Media Foundation H.264 video decoder is a Media Foundation Transform that
  supports decoding of Baseline, Main, and High profiles, up to level 5.1.
  We got a video with h264 profile 10 level 5.2
   
   How conversion from DTS for movie 'Butterfly on a Wheel (2007) 720p.BluRay.
   x264-ESiRM' finally worked?
   dts file has been converted to flac using Switch Sound File Converter
   flac to itunes conversion worked for our script    but flacs didn't work for
   following from the mkv,
    flac generated by ffmpeg
    alac generated by ffmpeg
    flv to mp3's alac version worked.. however it was truncaled to 55 mins always

  Subtitle file extraction alternative mkvextract:
    To exract subtitle track from mkv file
    Ref: http://manpages.ubuntu.com/manpages/hardy/man1/mkvextract.1.html
    $ mkvmerge.exe -i Video.mkv
      File D:\Video-Song.mkv: container: Matroska
      Track ID 0: subtitles (S_TEXT/ASS)
      Track ID 1: video (V_MPEG4/ISO/AVC)
      Track ID 2: audio (A_MPEG/L3)

    $ mkvextract tracks "0:Video-Song..srt"
#>

Param(
  [Parameter(Mandatory=$true)] [alias("a")] [string]$Action,
  [Parameter(Mandatory=$false)] [alias("s")] [string]$StreamPath,
  [Parameter(Mandatory=$false)] [alias("t")] [string]$TypeToExtract,
  [Parameter(Mandatory=$false)] [alias("o")] [string]$OutputDir,
  [Parameter(Mandatory=$false)] [alias("m")] [int]$CompressLevel,
  [Parameter(Mandatory=$false)] [alias("d")] [int]$DebugLevel,
  [Parameter(Mandatory=$false)] [alias("index")] [int]$SrtIndex)


#######################################################################################################
##################     Global variables declarations start      #################################
$FFMPEG2EXE="D:\PFiles_x64\PT\ffmpeg\bin\ffmpeg.exe"
# Instead check app path registry
$MEDIAINFOEXE="D:\PFiles_x64\PT\MediaInfo\MediaInfo.exe"
[int] $global:CompressLevel = 0


#######################################################################################################
#####################     Functions' Definitions Start      #####################################
#######################################################################################################

# Purpose of this function is to verify arguments
function VERIFY_PARAMETERS() {
  if (! (Test-Path -path $FFMPEG2EXE)) {
    Write-Host "Please correct FFMPEG2EXE path and then run the script " `
    "again.`n"
    return -1
  }

  # Verify Action empty
  if ([string]::IsNullOrEmpty($Action)) {
    Write-Host "Please tell me what to do!`n"
    return -2
  }
  # Verify Action specified
  else {
    $supportedActionArgument =[System.Collections.Generic.HashSet[string]] `
    @("convert"; "extract"; "merge"; "namefix"; "info"; "ffinfo"; "ffhelp" )
    <# previous demo for HashSet in Powershell
    $supportedActionArgument = New-Object System.Collections.Generic.HashSet[string]
    $supportedActionArgument.Add("convert")
    $supportedActionArgument.Add("extract")
    $supportedActionArgument.Add("merge")
    # this feature should move to 'Fix-MediaFileName.ps1'
    $supportedActionArgument.Add("namefix")
    $supportedActionArgument.Add("info")
    $supportedActionArgument.Add("ffinfo")
    $supportedActionArgument.Add("ffhelp") #>

    if (! $supportedActionArgument.Contains($Action) ) {
      Write-Host "Not sure what to do, you provided `"$Action`".`n"
      return -3
    }
  }

  # Input StreamPath can be Leaf or Container
  # Verify input path
  if (! $Action.Equals("ffhelp")) {
    if ([string]::IsNullOrEmpty($StreamPath) -Or !(Test-Path $StreamPath)) {
      Write-Host "Please provide correct source path. Current input `"" `
      "$StreamPath``n"
      return -1
    }
    elseif (Test-Path $StreamPath -PathType Container) {
      $script:IsSourceDirectory = $true
    }
  }

  # Verify for each action

  # Verify for convert
  # Use convert arg for coversion with no compression
  #  and for specified level of compression
  # Check common things between convert and merge
  if ($Action.ToLower().Equals("convert") -Or $Action.ToLower().Equals("merge")) {
    # verify compression level
    if ([string]::IsNullOrEmpty($OutputDir)) {
      $CompressLevel = 0
    }
    if ($CompressLevel -lt 0 -Or $CompressLevel -gt 2) {
      Write-Host "Unsupported level of compression.`n"
      return -1
    }
  }

  if ($Action.ToLower().Equals("extract")) {
    if ([string]::IsNullOrEmpty($TypeToExtract)) {
      Write-Host "No extraction type provided.`n"
      return -1
    }
    # Verify Type of Extraction provided
    $supportedExtractionArgument = [System.Collections.Generic.HashSet `
    [string]] @("audio"; "video"; "dts"; "text" )

    if (! $supportedExtractionArgument.Contains($TypeToExtract) ) {
      Write-Host "Please provide correct output type of extraction.`n " `
      "Incorrect extract type `"$TypeToExtract`".`n"
      return -1
    }
  }

  # if Output Directory is provided verify
  if (![string]::IsNullOrEmpty($OutputDir) -And !(Test-Path $OutputDir `
    -PathType Container)) {
    Write-Host "Incorrect output directory `"$OutputDir`"`n"
    return -1
  }

  return 0
}

# Cannot be implemented with return value, as this function output for
# MediaInfo is pipelined with return value
function PerformSimpleCommand() {
  # Show help for ffmpeg, required no other command line arguments
  if ($Action.ToLower().Equals("ffhelp")) {
    # & $FFMPEG2EXE -help
    & $FFMPEG2EXE x265 -help
    break
  }
  # Show Information with MediaInfo
  elseif ($Action.ToLower().Equals("info")) {
    if (! (Test-Path -path $MEDIAINFOEXE)) {
      Write-Host "Please correct path for media info and then run the script again.`n"
      break
    }
    Start-Process MediaInfo $StreamPath
    break
  }
  # Show Information with ffmpeg, observe for difference with mediainfo
  elseif ($Action.ToLower().Equals("ffinfo")) {
    & $FFMPEG2EXE -i $StreamPath
    break
  }
  # let's continue script execution for other options
}

function PerformOperationOnSingleFile ([int] $m_CompressLevel, [string] $SFilePath)
{
  # Get file extension
  $InputExt = Get-ChildItem $SFilePath | % {$_.Extension}
  if ($InputExt) {
  $InputExt = $InputExt.ToLower()
  if ($InputExt.Equals("")) {
    Write-Host "Unknown file extension"
    return
  }
  }
  else {
    Write-Host "null extenstion for file path $SFilePath"
    return  
  }

  # Entered path without extension
  $InputFileBaseName = $SFilePath.Substring(0, $SFilePath.Length - $InputExt.Length)
  if ($InputFileBaseName.Equals("")) {
    Write-Host "Wrong base file name"
    return
  }

  if ($Action.ToLower().Equals("extract")) {
    # Initializations
    $OutputExt=""

    # extract audio, output format will be mpeg 4
    # will work only for aac files
    # implement check for incompatible input
    if ($TypeToExtract.Tolower().Equals("audio")) {
      # output container will be mpeg-4, file format will be aac
      # do not provide an input that doesn't contain mpeg 4 aac 
      $OutputExt=".m4a"
      $OutputFilePath=$InputFileBaseName + $OutputExt
      # -vn because ffmpeg allows video on m4a, strange
      & $FFMPEG2EXE -i "$SFilePath" -vn -acodec copy -f mp4 "$OutputFilePath"
    }
    elseif ($TypeToExtract.Tolower().Equals("video")) {
      # debug
      # & $FFMPEG2EXE -i "$SFilePath"
      # break
      $OutputExt=".mp4"
      if ($InputExt.Equals(".mp4")) {
        $OutputExt = ".vid" + $OutputExt
      }
      $OutputFilePath=$InputFileBaseName + $OutputExt
      # if we want to chapter metadata from the video stream use this
      # & $FFMPEG2EXE -i "$SFilePath" -map_chapters -1 -an -sn -dn -vcodec copy -f mp4 "$OutputFilePath"
      # -vn because ffmpeg allows video on m4a, strange
      & $FFMPEG2EXE -i "$SFilePath" -an -sn -dn -vcodec copy -f mp4 "$OutputFilePath"
      # & $FFMPEG2EXE -i "$SFilePath" -map_chapters -1 -map 0:0 "$OutputFilePath"

    }
    # will work for dts audio files
    elseif ($TypeToExtract.Tolower().Equals("dts")) {
      # output container will be mpeg-4, file format will be aac
      # do not provide an input that doesn't contain mpeg 4 aac 
      $OutputExt=".m4a"
      $OutputFilePath=$InputFileBaseName + $OutputExt
      # & $FFMPEG2EXE -i "$SFilePath" "$OutputFilePath"
      & $FFMPEG2EXE -i "$SFilePath" -vn -acodec alac "$OutputFilePath"
    }
    elseif ($TypeToExtract.Tolower().Equals("srt")) {
      $OutputExt=".srt"
      $OutputFilePath=$InputFileBaseName + $OutputExt
      <# You will see some letters next to the codecs:
        D =Decoding supported, E =Encoding supported, V =Video codec, A =Audio codec,
        S =Subtitle codec, S =Supports draw_horiz_band, D =Supports direct rendering method 1, T =Supports weird frame 
      #>
      # & $FFMPEG2EXE -i "$SFilePath" -vn -an -codec:s:0.2 srt "$OutputFilePath"
      if ($SrtIndex.Equals("")) {
        Write-Host "cmd: & $FFMPEG2EXE -i `"$SFilePath`" -vn -an -scodec srt `"$OutputFilePath`""
        & $FFMPEG2EXE -i "$SFilePath" -vn -an -scodec srt "$OutputFilePath"
      }
      else {
        # example syntax for extracting PGS Subtitle
        # ffmpeg.exe -i input_file -scodec copy -map 0:2 out_filename.sup
        Write-Host "cmd: & $FFMPEG2EXE -i `"$SFilePath`" -vn -an -scodec`:$SrtIndex copy `"$OutputFilePath`""
        #& $FFMPEG2EXE -i "$SFilePath" -vn -an -scodec:"$SrtIndex" srt "$OutputFilePath"      
        #& $FFMPEG2EXE -i "$SFilePath" -vn -an -scodec:"$SrtIndex" srt language=spa "$OutputFilePath"
        & $FFMPEG2EXE -i "$SFilePath" -scodec copy -map 0:$SrtIndex "$OutputFilePath"
      }
    }
    else {
      Write-Host "Stream Converter: extraction of other types is not implemented yet.`r`n"
      return
    }

    # We do send input file to recycle bin after extraction
  }

  # Merge m4a and mp4 with samefile base name, input mp4 doesn't contain audio stream
  #  Use case: youtube downloaded videos
  elseif ($Action.ToLower().Equals("merge")) {
    # expects input the mp4 file
    if (! $InputExt.Equals(".mp4")) {
      Write-Host "Please input only the mp4 file"
      return
    }

    $AudioFilePath=$InputFileBaseName +".m4a"
    $VideoFilePath=$InputFileBaseName+".mp4"
    $FinalFilePath=$InputFileBaseName+"M.mp4"

    if (! (Test-Path -path $AudioFilePath)) {
      Write-Host "Incorrect audio file path.`n"
      return
    }

    & $FFMPEG2EXE -i "$VideoFilePath" -i "$AudioFilePath" -f mp4 -vcodec copy -acodec copy $FinalFilePath

    # Send input files to recycle bin
    if (Test-Path -path $FinalFilePath) {
      $sh = new-object -comobject "Shell.Application"
      $ns = $sh.Namespace(0).ParseName($AudioFilePath)
      $ns.InvokeVerb("delete")
      $ns = $sh.Namespace(0).ParseName($VideoFilePath)
      $ns.InvokeVerb("delete")
    }
  }
  else {
    # check and extract subtitle from mkv container
    if ($InputExt.Equals(".mkv")) {
      $OutputExt=".srt"
      Remove-Item ffmpeg*.log
      & $FFMPEG2EXE -report -i "$SFilePath" | Out-Null
      $LogFile = Get-ChildItem ffmpeg*.log | % {$_.FullName}
      $audioSearchResult = Select-String -Pattern "\s+Stream #\d:\d.*: Audio: \w+" $LogFile

      # Supported
      # aac (LC)
      # Write-Host "res " $audioSearchResult[0]
      [bool] $isAudioSupported = $false
      $rx = [regex]"Stream #\d:\d.*: Audio: opus"
      foreach ($audioInfo in $audioSearchResult) {
        $AINFO = ($rx.Match($audioInfo)).Captures[0].Value
        if ([string]::IsNullOrEmpty($AINFO)) {
          Write-Host "Supported audio format found."
          $isAudioSupported = $true
          break
        }
      }
      if (! $isAudioSupported) {
        Write-Host "Unsupported audio format found."
      }

      <#
      first preference
        - eng subrip
      2 - eng ass
      3 - subrip
      4 - ass
      5 - whatever else

      if total number of subtitle found is 1. Then we don't have any other option.


      High level overview
      1. Try to find subrip
      2. Try to find ass
      3. if previous ones failed then try the rest..
      #>

      # this procedure of subtitle extraction is triggered during convert
      # specificly extraction of srt is above

      # for ass files:
      # [srt @ 0000000000e74fe0] Unsupported subtitles codec: ass
      # Could not write header for output file #0 (incorrect codec parameters ?): Invalid argument
      # Enable auto detection of type: srt, ass, pgs, vobsub
      # preferred format srt
      # not always subrip
      $subSearchResult = Select-String -Pattern "\s+Stream #(\d|\d\d|\d\d\d):(\d|\d\d|\d\d\d)(.|\(\w+\)).*:\sSubtitle:\ssubrip" $LogFile
      Write-Host "Number of subtitles embedded found: " $subSearchResult.Count
      [string] $SINFO = ''
      $rx = [regex]"Stream #\d:\d.eng."
      foreach ($SubInfo in $subSearchResult) {
        $SINFO = ($rx.Match($SubInfo)).Captures[0].Value
        if (! [string]::IsNullOrEmpty($SINFO)) {
          $SINFO = $SubInfo
          Write-Host "match " $SINFO
          break
        }
      }

      # can be ass
      if ([string]::IsNullOrEmpty($SINFO)) {
        $subSearchResult = Select-String -Pattern "\s+Stream #(\d|\d\d|\d\d\d):(\d|\d\d|\d\d\d)(.|\(\w+\)).*:\sSubtitle:\sass" $LogFile
        Write-Host "Number of subtitles embedded found: " $subSearchResult.Count
        $rx = [regex]"Stream #\d:\d.eng."
        foreach ($SubInfo in $subSearchResult) {
          $SINFO = ($rx.Match($SubInfo)).Captures[0].Value
          if (! [string]::IsNullOrEmpty($SINFO)) {
            $SINFO = $SubInfo
            Write-Host "match " $SINFO
            break
          }
        }
      }

      # other format sub: vobsub, pgs etc
      if ([string]::IsNullOrEmpty($SINFO)) {
        $subSearchResult = Select-String -Pattern "\s+Stream #(\d|\d\d|\d\d\d):(\d|\d\d|\d\d\d)(.|\(\w+\)).*:\sSubtitle:\s" $LogFile
        Write-Host "Number of subtitles embedded found: " $subSearchResult.Count
        $rx = [regex]"Stream #\d:\d.eng."
        foreach ($SubInfo in $subSearchResult) {
          $SINFO = ($rx.Match($SubInfo)).Captures[0].Value
          if (! [string]::IsNullOrEmpty($SINFO)) {
            $SINFO = $SubInfo
            Write-Host "match " $SINFO
            break
          }
        }
      }
      <# previous regular expression pattern did not match, try regex for more than 10
      if ([string]::IsNullOrEmpty($SINFO) -and ($subSearchResult.count -gt 9)) {
        $rx = [regex]"Stream #\d:\d\d.eng."
        foreach ($SubInfo in $subSearchResult) {
          $SINFO = ($rx.Match($SubInfo)).Captures[0].Value
          if (! [string]::IsNullOrEmpty($SINFO)) {
            $SINFO = $SubInfo
            Write-Host "match " $SINFO
            break
          }
        }
      }#>
      # not expecting more than 99 subtitles, so such a regex check is omitted
      # specificly english could not be found, choose the first one
      if ([string]::IsNullOrEmpty($SINFO) -and ($subSearchResult.count -gt 0)) {
        Write-Host -NoNewline -ForegroundColor Green "Subtitle found in mkv container."
        $SINFO = [string] $subSearchResult[0]
        Write-Host -ForegroundColor Green "However, we could not find english. Choosing first one,`r`n $SINFO."
      }

      if ([string]::IsNullOrEmpty($SINFO)) {
        Write-Host -ForegroundColor Red "No subtitle found in mkv container."
      }
      else {
        $SINFO = [regex]::Replace($SINFO, ".*Stream", "Stream")
        Write-Host -NoNewline "`r`nSubtitle found in stream "
        # better regex to match, can be improved on 4th segment
        $resMatch = ([regex] "Stream #(\d|\d\d|\d\d\d):(\d|\d\d|\d\d\d)(.|\(\w+\))(\s|,\s\d+,).*:\sSubtitle:\s(\w+)").Match($SINFO).Groups
        $snMajorID = $resMatch[1].Value
        $snMinorID = $resMatch[2].Value
        $subType = $resMatch[5].Value
        Write-Host "Sub type: $subType" 
        switch ($subType) {
          "srt" { $OutputExt=".srt" }
          "ass" { $OutputExt=".ass" }
          default {}
        }
        # example, hdmv_pgs_subtitle (default)
        if ($subType.StartsWith("hdmv_pgs_subtitle")) { $OutputExt=".sup" }

        # not supported sub list
        # dvd_subtitle, 1920x1080, unsupported ref:
        # https://superuser.com/questions/1209091/extracting-subtitles-from-mkv-files-with-ffmpeg-or-mplayer
        if ($subType.StartsWith("dvd_subtitle")) { $OutputExt=".idx" }
        else {
          Write-Host "out ext: $OutputExt  $subType"
          $OutputFilePath=$InputFileBaseName + $OutputExt

          $SINFO = $snMajorID + ":" + $snMinorID
          Write-Host "sub codec id: $SINFO"
          Write-Host "Command: $FFMPEG2EXE -i in_file -vn -an -scodec:$SINFO copy $OutputFilePath"
          # index mapping not working with scodec: syntax
          # & $FFMPEG2EXE -i "$SFilePath" -vn -an -scodec:$SINFO copy "$OutputFilePath"
          & $FFMPEG2EXE -i "$SFilePath" -scodec copy -map $SINFO "$OutputFilePath"
        }
      }
      # for debugging, avoid converting the video file and sending it to recycle bin
      # break
    }
    
    $OutputExt=".mp4"
    # if $OutputDir is provided
    if ((! $OutputDir.Equals("")) -and (Test-Path $OutputDir)) {
      $OBaseName = Get-ChildItem $SFilePath | % {$_.BaseName}
      $DestFilePath=$OutputDir+"\"+$OBaseName+$OutputExt
    }
    else {
      if ($InputExt.Equals(".mp4")) {
        $DestFilePath=$InputFileBaseName+"_C"+$OutputExt
      }
      else {
        $DestFilePath=$InputFileBaseName+$OutputExt
      }
    }

    # convert video if compression level was specified, will convert any file, will also try to convert specified file even if it does not contain video stream i.e., text file,
    # so extension check have been added
    if ($m_CompressLevel -eq 2) {
      # & $FFMPEG2EXE -i "$SFilePath" -vcodec libx264 -preset veryslow -tune film -acodec copy $DestFilePath
      # to avoid menu of abba videos, remove chapters menu from mkv that are created from DVD: http://ffmpeg.zeranoe.com/forum/viewtopic.php?f=7&t=330
      # reduce bit rate to match better, bit rate: https://trac.ffmpeg.org/wiki/Limiting%20the%20output%20bitrate
      & $FFMPEG2EXE -i "$SFilePath" -b:v 700k -vcodec libx264 -preset veryslow -tune film -acodec copy -map_chapters -1 $DestFilePath
    }
    elseif ($m_CompressLevel -eq 1) {
      & $FFMPEG2EXE -i "$SFilePath" -vcodec libx264 -preset slow -tune film -acodec copy $DestFilePath
    }

    # default rule based on extension, only converts: mkv, flv, avi, mpg
    # for flv/ mkv we only change container and convert to mp4 or mnft... to do..
    # By default we don't touch mp4
    elseif ($InputExt.Equals(".mp4")) {
      Write-Host "Ignoring '$SFilePath'"
      return
    }
    elseif ($InputExt.Equals(".mkv") -Or $InputExt.Equals(".flv") -Or $InputExt.Equals(".mnft")) {
      # substituting srtIndex to specify one from multiple audio stream
      #& $FFMPEG2EXE -i "$SFilePath" -vcodec copy -acodec:$SrtIndex copy $DestFilePath
      # (this technique did not work for kung fu hustle file)

      # following workded
      # specify audio stream index in case of multiple audio streams
      # & $FFMPEG2EXE -i "$SFilePath" -vcodec copy -map 0`:0 -acodec copy -map 0`:2 $DestFilePath
      # Write-Host "Cmd:  $FFMPEG2EXE -i `"$SFilePath`" -vcodec copy -acodec copy `"$DestFilePath`""
      # map excludes all other streams,
      #  https://trac.ffmpeg.org/wiki/Map
      # Get rid of the dvd menu text type (-tn does not work)
      # -an -sn -dn 
      # ref: http://ffmpeg.org/ffmpeg.html#Stream-specifiers

      # # if we want to chapter metadata from the video stream use
      #   -map_chapters -1
      # & $FFMPEG2EXE -i "$SFilePath" -map -vcodec copy -map -acodec copy $DestFilePath
      if ($isAudioSupported) {
        & $FFMPEG2EXE -i "$SFilePath" -sn -dn -c:v copy -c:a copy $DestFilePath
        # use this forcefully select a different audio stream index
        # & $FFMPEG2EXE -i "$SFilePath" -sn -dn -c:v copy -map 0`:0 -c:a copy -map 0`:2 $DestFilePath
      }
      else {
        <# convert unsupported audio
          mp3 encode ref: https://trac.ffmpeg.org/wiki/Encode/MP3
        #>
        & $FFMPEG2EXE -i "$SFilePath" -sn -dn -c:v copy -c:a mp3 -q:a 3 $DestFilePath      
      }
    }
    <#
    Action convert should not perform compression, we only want container change
    # current implementation for converting donald duck, keeping mp3 audio, converting mpeg 4 visual simple to h264
    # for use in the script, has to be generalized
    elseif ($InputExt.Equals(".avi") -or $InputExt.Equals(".mpg") -or $InputExt.Equals(".mpeg")) {
      # ref: http://trac.ffmpeg.org/wiki/x264EncodingGuide
      # for animation
      # & $FFMPEG2EXE -i "$SFilePath" -acodec copy -c:v libx264 -preset slower -tune animation $DestFilePath
      # for high as 4.1, ref: http://superuser.com/questions/563997/how-can-i-set-a-h-264-profile-level-with-ffmpeg
      # ffmpeg -i input.mp4 -c:v libx264 -profile:v high -level:v 4.0 -c:a copy output.mp4
      # & $FFMPEG2EXE -i "$SFilePath" -c:a copy -c:v libx264 -profile:v high -level:v 4.1 $DestFilePath
      # for high quality compression to movies and videos
      # this is experimental audio, not going to use it
      <#if ($Action.ToLower().Equals("audio-aac")) {
        & $FFMPEG2EXE -i "$SFilePath" -acodec aac strict -2 -vcodec libx264 -preset veryslow -tune film $DestFilePath
      }
      else {#>
      #  Write-Host "cmd: $FFMPEG2EXE -i `"$SFilePath`" -acodec copy -vcodec libx264 -preset veryslow -tune film $DestFilePath"
       #   & $FFMPEG2EXE -i "$SFilePath" -acodec copy -vcodec libx264 -preset veryslow -tune film $DestFilePath
      #}

    #}
    else {
      Write-Host "Stream Converter: conversion from other containers is not implemented yet. You provided `'$InputExt`'`r`n"
      return
    }

    # Send to recycle bin if conversion produced an output
    if (Test-Path -path $DestFilePath) {
      $sh = new-object -comobject "Shell.Application"
      $ns = $sh.Namespace(0).ParseName($SFilePath)
      $ns.InvokeVerb("delete")
    }
    Remove-Item $LogFile
  }
}

function FixFileNames() {
  [int]$InputFileCount=0
  if ($Action.ToLower().Equals("namefix")) {
    Write-Host "Generating list of file to rename: "
  }
  else {
    Write-Host "Generating list of file to convert: "
  }

  # Name Fix for squar bracket problem
  # change these extension to lower case, it is safe for these file formats to convert to lowercase
  # .MKV will be handled by conversion, no need to rename
  $InputExt = ".MP4", ".AVI", ".MPG", ".MPEG", ".3GP"

  foreach ($item in Get-ChildItem -Recurse $StreamPath)
  {
    $fName = $item.FullName
    # if ((($InputExt.Count -eq 1 -and ($fName.EndsWith($InputExt[0]))) -or ($InputExt.Count -eq 2 -and ($fName.EndsWith($InputExt[0]) -or $fName.EndsWith($InputExt[1])))) -and ! $item.PSIsContainer) {
    if (! $item.PSIsContainer) {
      $i=0
      # rename file for all extension, we are not limiting rename
      for (; $i -lt $InputExt.Count; $i++)
      {
      # not changing extension to lowercase for other files
        if ($fName.EndsWith($InputExt[$i])) {
          <# bug fix updated logic
          $cleanName = $fName.Replace('[','(')
          $cleanName = $cleanName.Replace(']',')')#>
          # extension upper case to lower case
          $cleanBaseName = $item.Name.Replace('[','(')
          $cleanBaseName = $cleanBaseName.Replace(']',')')
          $cleanName = $fName.Replace($item.Name, $cleanBaseName)
          $cleanName = $cleanName.Substring(0, $cleanName.LastIndexOf($InputExt[$i])) + $InputExt[$i].ToLower()

          if ($fName.Equals($cleanName) -eq $false) {
            $InputFileCount++
            Write-Host " $InputFileCount. $cleanName"
            Rename-Item -literalPath $fName $cleanName
          }
          break
        }
      }
      # did not match with any extension; general rename
      if ($i -eq $InputExt.Count) {
        # bug: it replaces [ & ] inside the path as well, not only the filename
        # so if path contains those characters it does not work
        # replacement should be file only
        $cleanBaseName = $item.Name.Replace('[','(')
        $cleanBaseName = $cleanBaseName.Replace(']',')')
        $cleanName = $fName.Replace($item.Name, $cleanBaseName)

        if ($fName.Equals($cleanName) -eq $false) {
          $InputFileCount++
          Write-Host " $InputFileCount. $cleanName"
          if (Rename-Item -literalPath $fName $cleanName) {
            Write-Host "`t success"
          }
        }
      }
    }
  }

  if ($InputFileCount -eq 0) {
    Write-Host " No file to rename.`r`n"
  }
}

function SupportedExtension([string] $FileName) {
  $SupportedExtList = ".mp4", ".mkv", ".flv", ".mnft", ".avi", ".mpg", ".mpeg",".3gp"

  for ($i=0; $i -lt $SupportedExtList.Count; $i++) {
    if ($FileName.EndsWith($SupportedExtList[$i]) -or $FileName.EndsWith($SupportedExtList[$i].ToUpper())) {
      return $true
    }
  }
  return $false
}

#####################    Function Definition Ends       #####################################
#######################################################################################################

# Start of Main function
function Main() {
  if (VERIFY_PARAMETERS -le 0) {
    break
  }

  # not accepting return value for getting clean output
  PerformSimpleCommand

  <#  There can be 3 types of operation on directory
    # 1. convert
    # 2. merge
    # 3. namefix

    If compression is explicitly specified applied settings will be used.
    Otherwise, if input extension is flv or mkv or nmft only container will be changed.
    avi or mpg will be converted to h264 and aac, default compression tune is film, high compression is default
    mp4 files will be ignore.

    Default Output Container: mp4
    Default target audio: not changed
    Default target video: h264
    If extracting subtitle format will be: .srt
  #>


  if ($IsSourceDirectory) {
    FixFileNames
    if ($Action.ToLower().Equals("namefix")) {
      break
    }

    # for file update operations
    sleep 1

    # Perform operation for each stream file, recursively
    foreach ($item in Get-ChildItem -Recurse $StreamPath)
    {
      if (! $item.PSIsContainer) {
        $fName = $item.FullName
        if (SupportedExtension($fName)) {
          PerformOperationOnSingleFile $global:CompressLevel "$fName"
        }
        else {
          Write-Host "Extension not supported; skipping $fName"
        }
      }
    }
  }
  else {
    if (SupportedExtension($StreamPath)) {
      PerformOperationOnSingleFile $global:CompressLevel "$StreamPath"
    }
    else {
      Write-Host "Stream Converter: conversion from other containers/extension is not implemented yet.`r`n"
    }
  }
}

Main
